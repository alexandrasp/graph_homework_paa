from sets import Setimport copyclass Graph():    """docstring for Graph"""    def __init__(self):        self.vertices = []    '''Basic method to add vertices to the graph'''    def addVertices(self, volunta):        self.vertices.append(volunta)    '''Basic method to add edge to the graph'''    def addEdge(self, v1, v2):        # print(self.vertices[int(v1)-1].friendBond)        self.vertices[int(v1) - 1].friendBond.append(int(v2) - 1)        self.vertices[int(v2) - 1].friendBond.append(int(v1) - 1)    '''Method to detele edge where the bit is '0' acording bit sequence'''    def deleteEdge(self, graphAux, binRefence, V):        binRef = bin(binRefence)[2:].zfill(int(V))        #print binRef        for x in range(0, len(binRef)):            if int(binRef[x])==0:                #print(binRef[x], x)                for y in range(0, len(graphAux)):                    if x in graphAux[y].friendBond:                        graphAux[y].friendBond.remove(x)    '''Method to do copies from original graph to an especifical bit sequence and return the copy'''    def copyGraphWMask(self, X, V):        copyGraph = []        binRef = bin(X)[2:].zfill(int(V))        for x in range(0, int(V)):            if(int(binRef[x])==1):                copyGraph.append(copy.deepcopy(self.vertices[x]))        return copyGraph    '''Most important method!! It is doing the basic loop to find all possible answer andjoin it with a conexity operation to validate the solution! It return only one solution'''    def coberturaFocos(self, V, F):        aux = Set([])        auxConexid = Set([])        solution = []        focusCobertos = Set([])        repeat = 2**int(V)-1        for x in range(repeat, 0, -1):            aux = self.copyGraphWMask(x, V)            if(solution):                if(len(solution) > len(aux)):                    for y in range(0, len(aux)):                        focusCobertos = focusCobertos | Set(aux[y].focusKnown)                        if(len(focusCobertos) == int(F)):                            self.deleteEdge(aux, x, V)                        #verificar conexao                            auxConexid = self.dfs(aux, aux[0].nodeId)                            if(len(aux)==len(auxConexid)):                                solution = copy.deepcopy(aux)            else:                    #print("first")                solution = copy.deepcopy(aux)                '''for x in range(0, len(solution)):                    print solution[x].nodeId + 1                '''                #print(auxConexid)            focusCobertos.clear()        #self.showGraph(V)        return solution    '''Basic method to show adjacency list from the graph'''    def showGraph(self, V):        for x in range(0, int(V)):            print(self.vertices[x].friendBond)    '''DFS to verify conexity in graph that is a possible solution'''    def dfs(self, graph, start, visited=None):        #print(start, ":start")        #print(len(graph), "Noo")        if visited is None:            visited = set()        visited.add(start)        for x in range(0, len(graph)):            if(graph[x].nodeId == start):                break        if(graph[x].friendBond):            for next in (set(graph[x].friendBond) - visited):                #print(next,"next")                self.dfs(graph, next, visited)        return visited